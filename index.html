<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vibe Racing - Hackathon Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        #ui { position: absolute; top: 20px; left: 20px; color: #0f0; pointer-events: none; text-shadow: 0 0 5px #0f0; }
        #video-container { position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px; border: 2px solid #0f0; border-radius: 8px; overflow: hidden; transform: scaleX(-1); }
        video { width: 100%; height: 100%; object-fit: cover; }
        .loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 1.5rem; }
    </style>
</head>
<body>

    <div id="ui">
        <h1>VIBE RACING üèÅ</h1>
        <p id="status">Iniciando motores (IA)...</p>
        <p>Inclinaci√≥n: <span id="val-inclinacion">0</span></p>
        <p>Vibe Boost: <span id="val-boost">Apagado</span></p>
    </div>

    <div id="video-container">
        <video id="webcam" autoplay playsinline></video>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { FaceLandmarker, FilesetResolver } from "vision";

        let faceLandmarker;
        let webcam = document.getElementById("webcam");
        let lastVideoTime = -1;

        // --- 1. CONFIGURACI√ìN DE THREE.JS ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 5, 15);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Suelo (Grid)
        const grid = new THREE.GridHelper(100, 50, 0xff00ff, 0x222222);
        scene.add(grid);

        // El "Auto"
        const geometry = new THREE.BoxGeometry(1, 0.5, 2);
        const material = new THREE.MeshPhongMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 0.5 });
        const car = new THREE.Mesh(geometry, material);
        car.position.y = 0.25;
        scene.add(car);

        // Luces
        const light = new THREE.PointLight(0xffffff, 10);
        light.position.set(0, 5, 2);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        camera.position.set(0, 3, 6);
        camera.lookAt(car.position);

        // --- 2. CONFIGURACI√ìN DE IA (MediaPipe) ---
        async function setupIA() {
            const filesetResolver = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task` },
                runningMode: "VIDEO",
                numFaces: 1
            });
            startWebcam();
        }

        async function startWebcam() {
            const constraints = { video: true };
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            webcam.srcObject = stream;
            webcam.addEventListener("loadeddata", () => {
                document.getElementById("status").innerText = "IA Online - ¬°Mueve la cabeza!";
                animate();
            });
        }

        // --- 3. L√ìGICA DE CONTROL Y ANIMACI√ìN ---
        function animate() {
            const startTimeMs = performance.now();
            
            if (webcam.currentTime !== lastVideoTime) {
                lastVideoTime = webcam.currentTime;
                const results = faceLandmarker.detectForVideo(webcam, startTimeMs);

                if (results.faceLandmarks && results.faceLandmarks.length > 0) {
                    const landmarks = results.faceLandmarks[0];

                    // Control Lateral (Punto de la nariz vs orejas o centro)
                    // Usamos el punto 4 (nariz) y el 152 (ment√≥n) para estimar inclinaci√≥n
                    const nose = landmarks[4];
                    const rotation = (nose.x - 0.5) * -10; // Sensibilidad
                    car.position.x = THREE.MathUtils.lerp(car.position.x, rotation, 0.1);
                    document.getElementById("val-inclinacion").innerText = rotation.toFixed(2);

                    // Vibe Boost (Apertura de boca - distancia entre labio superior e inferior)
                    const topLip = landmarks[13];
                    const bottomLip = landmarks[14];
                    const mouthOpen = Math.abs(topLip.y - bottomLip.y);

                    if (mouthOpen > 0.05) { // Umbral de "boca abierta"
                        car.material.color.setHex(0xff0000);
                        car.material.emissive.setHex(0xff0000);
                        document.getElementById("val-boost").innerText = "¬°M√ÅXIMO VIBE!";
                        grid.position.z += 0.2; // M√°s r√°pido
                    } else {
                        car.material.color.setHex(0x00ffff);
                        car.material.emissive.setHex(0x00ffff);
                        document.getElementById("val-boost").innerText = "Normal";
                        grid.position.z += 0.05; // Velocidad base
                    }
                }
            }

            // Efecto de carretera infinita
            if (grid.position.z > 2) grid.position.z = 0;

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        setupIA();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>